#!/usr/bin/env python3
import sys, os, logging, argparse

cimeroot = os.getenv("CIMEROOT")
sys.path.append(os.path.join(cimeroot, "CIME", "Tools"))

import glob, re
from standard_script_setup import *
from CIME import utils
from CIME.utils import expect, run_bld_cmd_ensure_logging, safe_copy
from CIME.build import get_standard_makefile_args
from CIME.case import Case

logger = logging.getLogger(__name__)


def parse_command_line(args, description):
    ###############################################################################
    parser = argparse.ArgumentParser(
        usage="""\n{0} [--debug]
OR
{0} --verbose
OR
{0} --help

\033[1mEXAMPLES:\033[0m
    \033[1;32m# Run \033[0m
    > {0}
""".format(
            os.path.basename(args[0])
        ),
        description=description,
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )

    utils.setup_standard_logging_options(parser)

    parser.add_argument("buildroot", help="build path root")

    parser.add_argument("installpath", help="install path ")

    parser.add_argument(
        "caseroot", nargs="?", default=os.getcwd(), help="Case directory to build"
    )

    args = utils.parse_args_and_handle_standard_logging_options(args, parser)

    return args.buildroot, args.installpath, args.caseroot


###############################################################################
def buildlib(bldroot, installpath, case):
    ###############################################################################
    cime_model = case.get_value("MODEL")
    caseroot = case.get_value("CASEROOT")
    pio_version = case.get_value("PIO_VERSION")
    srcroot = case.get_value("SRCROOT")
    scorpio_src_root_dir = None
    if cime_model == "e3sm":
        scorpio_src_root_dir = os.path.join(srcroot, "externals")
        # Scorpio classic is derived from PIO1
        scorpio_classic_dir = "scorpio_classic"
        # Scorpio is derived from PIO2
        scorpio_dir = "scorpio"
        scorpio_classic_src_dir = os.path.join(
            scorpio_src_root_dir, scorpio_classic_dir
        )
        scorpio_src_dir = os.path.join(scorpio_src_root_dir, scorpio_dir)
        if (
            not os.path.isdir(scorpio_src_root_dir)
            or not os.path.isdir(scorpio_classic_src_dir)
            or not os.path.isdir(scorpio_src_dir)
        ):
            scorpio_src_root_dir = None

    # If variable PIO_VERSION_MAJOR is defined in the environment then
    # we assume that PIO is installed on the system
    # and expect to find
    # PIO_LIBDIR, PIO_INCDIR, PIO_TYPENAME_VALID_VALUES
    # also defined in the environment.  In this case we
    # will use the installed pio and not build it here.
    installed_pio_version = os.environ.get("PIO_VERSION_MAJOR")
    logger.info(
        "pio_version_major = {} pio_version = {}".format(
            installed_pio_version, pio_version
        )
    )
    if installed_pio_version is not None and int(installed_pio_version) == pio_version:
        logger.info("Using installed PIO library")
        _set_pio_valid_values(case, os.environ.get("PIO_TYPENAME_VALID_VALUES"))
        return

    pio_model = "pio{}".format(pio_version)
    pio_dir = os.path.join(bldroot, pio_model)
    if not os.path.isdir(pio_dir):
        os.makedirs(pio_dir)
    casetools = case.get_value("CASETOOLS")
    if scorpio_src_root_dir:
        # Use old genf90 until "short" type is supported
        cmake_opts = "-D GENF90_PATH=" \
                   + os.path.join(scorpio_src_root_dir, scorpio_dir, "src/genf90")
    elif pio_version == 1:
        cmake_opts = "-D GENF90_PATH=$CIMEROOT/CIME/non_py/externals/genf90"
    else:
        cmake_opts = "-D GENF90_PATH=" + srcroot + "/libraries/parallelio/scripts/"

    cmake_opts += f" -D CMAKE_INSTALL_PREFIX={installpath}"
    cmake_opts += f" -D pio_SOURCE_DIR=${scorpio_src_dir}"
    cmake_opts += f" -D pio_BINARY_DIR=${pio_dir}"

    cmake_lists_loc = os.path.join(cimeroot, "CIME", "Tools")

    # Run cmake first
    cmd = f"cmake -DCASEROOT={caseroot} {cmake_opts} {cmake_lists_loc}"
    run_bld_cmd_ensure_logging(cmd, logger, from_dir=pio_dir)

    # Then run gmake on the cmake generated Makefile
    gmake_cmd = case.get_value("GMAKE")
    run_bld_cmd_ensure_logging(
        "{} -j {} install".format(gmake_cmd, case.get_value("GMAKE_J")),
        logger,
        from_dir=pio_dir,
    )

    if pio_version == 1:
        expect_string = "D_NETCDF;"
        pnetcdf_string = "D_PNETCDF"
        netcdf4_string = "D_NETCDF4"
    else:
        expect_string = "NetCDF_C_LIBRARY-ADVANCED"
        pnetcdf_string = "WITH_PNETCDF:BOOL=ON"
        netcdf4_string = "NetCDF_C_HAS_PARALLEL:BOOL=TRUE"

    # make sure case pio_typename valid_values is set correctly
    expect_string_found = False
    pnetcdf_found = False
    netcdf4_parallel_found = False

    cache_file = open(os.path.join(pio_dir, "CMakeCache.txt"), "r")
    for line in cache_file:
        if re.search(expect_string, line):
            expect_string_found = True
        if re.search(pnetcdf_string, line):
            pnetcdf_found = True
        if re.search(netcdf4_string, line):
            netcdf4_parallel_found = True

    expect(expect_string_found, "CIME models require NETCDF in PIO build")
    valid_values = "netcdf"
    if pnetcdf_found:
        valid_values += ",pnetcdf"
    if netcdf4_parallel_found:
        valid_values += ",netcdf4p,netcdf4c"

    _set_pio_valid_values(case, valid_values)


def _set_pio_valid_values(case, valid_values):
    # nothing means use the general default
    valid_values += ",nothing"
    logger.warning("Updating valid_values for PIO_TYPENAME: {}".format(valid_values))
    env_run = case.get_env("run")
    env_run.set_valid_values("PIO_TYPENAME", valid_values)

    for comp in case.get_values("COMP_CLASSES"):
        comp_pio_typename = "{}_PIO_TYPENAME".format(comp)
        current_value = case.get_value(comp_pio_typename)
        if current_value not in valid_values:
            logger.warning(
                "Resetting PIO_TYPENAME=netcdf for component {}".format(comp)
            )
            env_run.set_value(comp_pio_typename, "netcdf")


def _main(argv, documentation):
    bldroot, installpath, caseroot = parse_command_line(argv, documentation)
    with Case(caseroot, read_only=False) as case:
        buildlib(bldroot, installpath, case)


if __name__ == "__main__":
    _main(sys.argv, __doc__)
